<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Searchster P2P - Astrological Matchmaking</title>
    <style>
        :root {
            --dark-blue-900: #0c1425;
            --dark-blue-800: #1e293b;
            --dark-blue-700: #334155;
            --dark-blue-600: #475569;
            --cosmic-purple: #8b5cf6;
            --cosmic-pink: #ec4899;
            --golden: #fbbf24;
            --text-white: #ffffff;
            --text-gray: #cbd5e1;
            --text-muted: #94a3b8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--dark-blue-900) 0%, var(--dark-blue-800) 50%, #1a1a2e 100%);
            color: var(--text-white);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* Starry background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.6), transparent),
                radial-gradient(2px 2px at 160px 30px, #fff, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: twinkle 4s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes twinkle {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        header {
            background: rgba(12, 20, 37, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--cosmic-purple);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo h1 {
            font-size: 1.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .notification-bell, .profile-btn, .settings-btn {
            background: none;
            border: none;
            color: var(--text-gray);
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .profile-btn {
            visibility: hidden;
        }
        
        .profile-btn.visible {
            visibility: visible;
        }

        .notification-bell:hover, .profile-btn:hover, .settings-btn:hover {
            color: var(--text-white);
            background: rgba(139, 92, 246, 0.2);
        }

        .notification-badge {
            position: relative;
        }

        .notification-badge::after {
            content: attr(data-count);
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--cosmic-pink);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .section {
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-gray);
        }

        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--dark-blue-600);
            border-radius: 0.5rem;
            background: rgba(51, 65, 85, 0.5);
            color: var(--text-white);
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--cosmic-purple);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        .gender-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .gender-group h4 {
            margin-bottom: 1rem;
            color: var(--cosmic-purple);
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .radio-item, .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
        }

        .radio-item:hover, .checkbox-item:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        input[type="radio"], input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        button {
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(139, 92, 246, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .hidden {
            display: none !important;
        }

        .location-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--dark-blue-700);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .location-suggestion {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
            transition: background-color 0.2s ease;
        }

        .location-suggestion:hover {
            background: rgba(139, 92, 246, 0.2);
        }

        .location-suggestion:last-child {
            border-bottom: none;
        }

        .form-group {
            position: relative;
        }

        .matches-grid {
            display: grid;
            gap: 1rem;
            margin-top: 2rem;
        }

        .match-card {
            background: rgba(51, 65, 85, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 0.75rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .match-card:hover {
            border-color: var(--cosmic-purple);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(139, 92, 246, 0.2);
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .match-username {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .badge {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .badge-golden {
            background: var(--golden);
            color: var(--dark-blue-900);
        }

        .badge-male {
            background: #3b82f6;
            color: white;
        }

        .badge-female {
            background: #ec4899;
            color: white;
        }

        .compatibility-score {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .match-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text-white);
        }

        .chat-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: rgba(12, 20, 37, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid var(--cosmic-purple);
            transition: right 0.3s ease;
            z-index: 200;
            display: flex;
            flex-direction: column;
        }

        .chat-panel.open {
            right: 0;
        }

        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .chat-input-area {
            padding: 1rem;
            border-top: 1px solid rgba(139, 92, 246, 0.3);
        }

        .chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input input {
            flex: 1;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 0.75rem;
            max-width: 80%;
        }

        .message.own {
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            margin-left: auto;
            color: white;
        }

        .message.other {
            background: rgba(51, 65, 85, 0.8);
            color: var(--text-white);
        }

        .profile-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .profile-content {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-gray);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        .profile-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            overflow: hidden;
        }

        .natal-data {
            background: rgba(51, 65, 85, 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
        }

        .copy-btn {
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid var(--cosmic-purple);
            color: var(--cosmic-purple);
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-btn:hover {
            background: rgba(139, 92, 246, 0.3);
        }
        
        .toast-notification {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, var(--cosmic-purple), var(--cosmic-pink));
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: bottom 0.5s ease-in-out;
        }

        .toast-notification.show {
            bottom: 20px;
        }


        @media (max-width: 768px) {
            .gender-selection {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .match-details {
                grid-template-columns: 1fr;
            }
            
            .chat-panel {
                width: 100%;
                right: -100%;
            }
            
            .profile-content {
                margin: 1rem;
                max-width: calc(100% - 2rem);
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="header-content">
            <div class="logo">
                <span style="font-size: 1.5rem;">✨</span>
                <h1>Searchster</h1>
                <span style="color: var(--text-muted); font-size: 0.9rem;">Astrological Matchmaking</span>
            </div>
            <div class="header-actions">
                <button class="settings-btn" onclick="openSettings()">
                    <span style="font-size: 1.2rem;">⚙️</span>
                </button>
                <button class="notification-bell" id="notificationBell" onclick="toggleNotifications()">
                    <span style="font-size: 1.2rem;">🔔</span>
                </button>
                <button class="profile-btn" onclick="openProfile()">
                    <span style="font-size: 1.2rem;">👤</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Welcome Screen -->
    <div id="welcomeScreen" class="section">
        <div class="card">
            <h2 style="text-align: center; margin-bottom: 2rem; color: var(--cosmic-purple);">Welcome to Searchster P2P</h2>
            <p style="text-align: center; margin-bottom: 2rem; color: var(--text-gray);">
                Discover your cosmic connections through advanced astrological synastry
            </p>
            
            <div class="form-group">
                <label for="username">Username</label>
                <input type="text" id="username" placeholder="Enter your username" maxlength="30">
            </div>
            
            <div class="form-group">
                <label for="dateOfBirth">Date of Birth</label>
                <input type="date" id="dateOfBirth">
            </div>
            
            <div class="form-group">
                <label for="timeOfBirth">Time of Birth</label>
                <input type="time" id="timeOfBirth">
            </div>
            
            <div class="form-group">
                <label for="placeOfBirth">Place of Birth</label>
                <input type="text" id="placeOfBirth" placeholder="Start typing city name..." autocomplete="off">
                <div id="locationSuggestions" class="location-suggestions hidden"></div>
            </div>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="timeCertain"> 
                    Birth time is certain (verified from birth certificate)
                </label>
            </div>

            <!-- Gender Selection -->
            <div class="gender-selection">
                <div class="gender-group">
                    <h4>I am a:</h4>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="genderMan" name="gender" value="man" checked>
                            <label for="genderMan">♂ Man</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="genderWoman" name="gender" value="woman">
                            <label for="genderWoman">♀ Woman</label>
                        </div>
                    </div>
                </div>
                
                <div class="gender-group">
                    <h4>I'm looking for:</h4>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="lookingForMen" value="men">
                            <label for="lookingForMen">♂ Men</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="lookingForWomen" value="women" checked>
                            <label for="lookingForWomen">♀ Women</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 2rem;">
                <button onclick="connect()" id="connectBtn">Connect to Searchster Network</button>
            </div>
        </div>
    </div>

    <!-- Matches Screen -->
    <div id="matchesScreen" class="section hidden">
        <div class="card">
            <h2 style="color: var(--cosmic-purple); margin-bottom: 1rem;">Your Cosmic Matches</h2>
            
            <div style="display: flex; gap: 1rem; margin-bottom: 2rem;">
                <div style="flex: 1;">
                    <label for="minAge">Min Age</label>
                    <input type="number" id="minAge" value="18" min="18" max="99">
                </div>
                <div style="flex: 1;">
                    <label for="maxAge">Max Age</label>
                    <input type="number" id="maxAge" value="99" min="18" max="99">
                </div>
                <div style="display: flex; align-items: flex-end;">
                    <button onclick="findMatches()">Refresh Matches</button>
                </div>
            </div>
            
            <div id="matchesList" class="matches-grid"></div>
        </div>
    </div>

    <!-- Chat Panel -->
    <div id="chatPanel" class="chat-panel">
        <div class="chat-header">
            <div>
                <h3 id="chatUsername">Chat</h3>
                <p style="color: var(--text-muted); font-size: 0.9rem;">Online now</p>
            </div>
            <div style="display: flex; gap: 0.5rem;">
                <button class="copy-btn" onclick="viewChatUserProfile()">View Profile</button>
                <button class="close-btn" onclick="closeChat()">×</button>
            </div>
        </div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="chat-input-area">
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleChatKeyPress(event)">
                <button onclick="sendMessage()">Send</button>
            </div>
            <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                <button class="copy-btn" onclick="saveChat()" style="flex: 1;">Save Chat</button>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="profile-modal hidden">
        <div class="profile-content">
            <button class="close-btn" onclick="closeProfile()">×</button>
            <div id="profileContent"></div>
        </div>
    </div>

    <!-- Notification Modal -->
    <div id="notificationModal" class="profile-modal hidden">
        <div class="profile-content">
            <button class="close-btn" onclick="closeNotifications()">×</button>
            <h3 style="margin-bottom: 1rem; color: var(--cosmic-purple);">Notifications</h3>
            <div id="notificationsList"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="profile-modal hidden">
        <div class="profile-content">
            <button class="close-btn" onclick="closeSettings()">×</button>
            <h3 style="margin-bottom: 1rem; color: var(--cosmic-purple);">⚙️ Settings</h3>
            
            <div class="card" style="margin-bottom: 1rem;">
                <h4 style="color: var(--cosmic-pink); margin-bottom: 1rem;">Update Your Information</h4>
                
                <div class="form-group">
                    <label for="settingsUsername">Username</label>
                    <input type="text" id="settingsUsername" placeholder="Enter new username">
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group">
                        <label for="settingsDateOfBirth">Date of Birth</label>
                        <input type="date" id="settingsDateOfBirth">
                    </div>
                    <div class="form-group">
                        <label for="settingsTimeOfBirth">Time of Birth</label>
                        <input type="time" id="settingsTimeOfBirth">
                    </div>
                </div>
                
                <div class="form-group" style="position: relative;">
                    <label for="settingsPlaceOfBirth">Place of Birth</label>
                    <input type="text" id="settingsPlaceOfBirth" placeholder="Enter city, state/country">
                    <div id="settingsLocationSuggestions" class="location-suggestions hidden"></div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group">
                        <label for="settingsGender">Gender</label>
                        <select id="settingsGender">
                            <option value="man">Man</option>
                            <option value="woman">Woman</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="settingsTimeCertain"> 
                            Birth time is certain
                        </label>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="settingsLookingForMen"> 
                            Looking for men
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="settingsLookingForWomen"> 
                            Looking for women
                        </label>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="settingsBio">Bio (500 characters max)</label>
                    <textarea id="settingsBio" rows="3" maxlength="500" placeholder="Tell us about yourself..."></textarea>
                </div>
                
                <div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
                    <button onclick="saveSettings()" style="flex: 1;">Save Changes</button>
                    <button onclick="closeSettings()" style="flex: 1; background: var(--dark-blue-600);">Cancel</button>
                </div>
            </div>
            
            <div class="card">
                <h4 style="color: var(--cosmic-pink); margin-bottom: 1rem;">Astrological System</h4>
                <p style="color: var(--text-muted); margin-bottom: 0.5rem;">✨ Using Fagan/Bradley Ayanamsa (Sidereal)</p>
                <p style="color: var(--text-muted); margin-bottom: 0.5rem;">🏠 Using Placidus House System</p>
                <p style="color: var(--text-muted);">💫 16 planetary bodies calculated for complete analysis</p>
            </div>
        </div>
    </div>
    
    <div id="toastNotification" class="toast-notification"></div>

    <script>
    // --- CONSOLIDATED JAVASCRIPT ---

    // --- sweph-reference.js (Placeholder, logic moved to AstrologyEngine) ---
    class SwissEphemeris {
        // This class is kept for structure but its calculation logic is now
        // superseded by the more accurate methods in AstrologyEngine.
        constructor() {
            this.SEFLG_SWIEPH = 2; this.SEFLG_SIDEREAL = 64;
        }
    }

    // --- geocoder-reference.js ---
    class BrowserGeocoder {
        constructor(options = {}) {
            this.provider = options.provider || 'openstreetmap';
            this.cache = new Map();
        }
        async geocode(address) {
            const cacheKey = `geocode:${address}`;
            if (this.cache.has(cacheKey)) return this.cache.get(cacheKey);
            const result = await this.geocodeWithOSM(address);
            this.cache.set(cacheKey, result);
            return result;
        }
        async geocodeWithOSM(address) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.length === 0) return [];
                const item = data[0];
                return [{
                    latitude: parseFloat(item.lat),
                    longitude: parseFloat(item.lon),
                    formattedAddress: item.display_name,
                    city: item.address?.city || item.address?.town || item.address?.village || null,
                }];
            } catch (error) { throw new Error(`Geocoding failed: ${error.message}`); }
        }
        async suggest(query, limit = 10) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=${limit}&addressdetails=1`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.map(item => ({
                    display_name: item.display_name,
                    latitude: parseFloat(item.lat),
                    longitude: parseFloat(item.lon),
                }));
            } catch (error) { throw new Error(`Location suggestion failed: ${error.message}`); }
        }
    }

    // --- core.js ---
    class SearchsterApp {
        constructor() {
            this.currentUser = null; this.matches = []; this.notifications = [];
            this.mutedIPs = new Set(); this.chatHistory = new Map();
            this.currentChatUser = null; this.domReady = false;
        }
        initializeDOMFeatures() {
            this.domReady = true;
            this.startNotificationPolling();
            setInterval(() => {
                const matchesScreen = document.getElementById('matchesScreen');
                if (matchesScreen && !matchesScreen.classList.contains('hidden')) {
                    findMatches();
                }
            }, 60000);
        }
        saveUserData() {}
        muteIP(ipAddress) { this.mutedIPs.add(ipAddress); }
        startNotificationPolling() {
            setInterval(() => this.updateNotificationBell(), 5000);
        }
        addNotification(notification) {
            this.notifications.unshift(notification);
            this.updateNotificationBell();
        }
        updateNotificationBell() {
            if (!this.domReady) return;
            const bell = document.getElementById('notificationBell');
            const unreadCount = this.notifications.filter(n => !n.read).length;
            if (unreadCount > 0) {
                 bell.classList.add('notification-badge');
                 bell.setAttribute('data-count', unreadCount);
            } else {
                 bell.classList.remove('notification-badge');
                 bell.removeAttribute('data-count');
            }
        }
        getUserIP() { return this.generateIP(); }
        generateIP() { return `192.168.1.${Math.floor(Math.random() * 254) + 1}`; }
    }

    // --- astrology.js (HEAVILY REVISED) ---
    class AstrologyEngine {
        constructor() {
            // Updated Ayanamsa to match reference: 24°32'26"
            this.FAGAN_BRADLEY_AYANAMSA = 24 + 32/60 + 26/3600; // 24.540555...
            this.geocodeCache = new Map();
            this.ZODIAC_SIGNS = ['Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo', 'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'];
            this.sweph = null; this.geocoder = null; this.initialized = false;

            // Math helpers
            this.RADEG = 180 / Math.PI;
            this.DEGRAD = Math.PI / 180;
            this.normalize = (v) => { let b = v / 360; return (b - Math.floor(b)) * 360; };
        }

        initialize() {
            if (typeof SwissEphemeris === 'undefined' || typeof BrowserGeocoder === 'undefined') {
                console.error('Core libraries not loaded'); return;
            }
            this.sweph = new SwissEphemeris();
            this.geocoder = new BrowserGeocoder({ provider: 'openstreetmap' });
            this.initialized = true;
        }

        // Revised: Main calculation function
        async calculateNatalChart(dateOfBirth, timeOfBirth, placeOfBirth) {
            const coords = await this.geocodeLocation(placeOfBirth);
            if (!coords) return null;

            const date = new Date(`${dateOfBirth}T${timeOfBirth}`);
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();
            const hours = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;

            // Julian Day and time corrections
            const jd_ut = this.getJulianDay(year, month, day, hours);
            const deltaT = this.getDeltaT(year); // Seconds
            const jd_et = jd_ut + deltaT / 86400.0; // Ephemeris Time
            const T = (jd_et - 2451545.0) / 36525; // Julian centuries

            // Core astrological factors
            const e = this.getMeanObliquity(T); // Obliquity of the ecliptic
            const LST = this.getLST(jd_ut, coords.lon); // Local Sidereal Time
            const RAMC = LST * 15; // Right Ascension of the Midheaven

            // Calculate house cusps using proper Placidus algorithm
            const houses = this.getPlacidusHouses(RAMC, e, coords.lat);
            
            const positions = {};
            // More accurate planetary calculations
            const planetFuncs = {
                sun: this.getSunLon, moon: this.getMoonLon, mercury: this.getMercuryLon, venus: this.getVenusLon,
                mars: this.getMarsLon, jupiter: this.getJupiterLon, saturn: this.getSaturnLon, uranus: this.getUranusLon,
                neptune: this.getNeptuneLon, pluto: this.getPlutoLon, trueNode: this.getMeanNode
            };

            for (const [name, func] of Object.entries(planetFuncs)) {
                const lon = func.bind(this)(T) - this.FAGAN_BRADLEY_AYANAMSA;
                positions[`${name}Position`] = this.normalize(lon);
            }
            // Chiron is complex, use a simpler model
            positions.chironPosition = this.normalize(207.224 + 1364.681 * T - this.FAGAN_BRADLEY_AYANAMSA);

            // Assign houses to all calculated positions
            Object.keys(positions).forEach(key => {
                positions[key.replace('Position', 'PositionHouse')] = this.getPlanetHouse(positions[key], houses);
            });

            // Calculate Ascendant and other points
            positions.ascendantPosition = houses[0];
            positions.midHeavenPosition = houses[9];
            positions.vertexPosition = this.getVertex(RAMC, e, coords.lat);
            positions.fortunaPosition = this.normalize(positions.ascendantPosition + positions.moonPosition - positions.sunPosition);

            // Assign houses to these points as well
            positions.ascendantPositionHouse = 1;
            positions.midHeavenPositionHouse = 10;
            positions.vertexPositionHouse = this.getPlanetHouse(positions.vertexPosition, houses);
            positions.fortunaPositionHouse = this.getPlanetHouse(positions.fortunaPosition, houses);

            positions.houses = houses;
            positions.natalAspects = this.calculateNatalAspects(positions);
            return positions;
        }

        // --- NEW AND REVISED CALCULATION HELPERS ---

        getJulianDay(y, m, d, h) {
            if (m <= 2) { y -= 1; m += 12; }
            const A = Math.floor(y / 100);
            const B = 2 - A + Math.floor(A / 4);
            return Math.floor(365.25 * (y + 4716)) + Math.floor(30.6001 * (m + 1)) + d + (h / 24) + B - 1524.5;
        }

        getDeltaT(year) {
            // Simplified polynomial approximation for Delta T
            const t = (year - 2000) / 100;
            if (year < 948) return 2177 + 497 * t + 47.97 * t * t;
            return 102 + 102 * t + 25.3 * t * t;
        }

        getMeanObliquity(T) {
            const U = T / 100;
            return 23.43929111 - (4680.93 * U - 1.55 * U * U + 1999.25 * U * U * U - 51.38 * U * U * U * U) / 3600;
        }

        getLST(jd, lon) {
            const T = (jd - 2451545.0) / 36525;
            let gmst = 280.46061837 + 360.98564736629 * (jd - 2451545.0) + 0.000387933 * T * T - T * T * T / 38710000.0;
            gmst = this.normalize(gmst);
            return this.normalize(gmst + lon) / 15;
        }
        
        // --- REVISED: Accurate Placidus House Calculation ---
        getPlacidusHouses(ramc, e, lat) {
            const houses = new Array(12);
            const D = Math.asin(Math.sin(this.DEGRAD * e) * Math.sin(this.DEGRAD * ramc));
            const ascendant = this.normalize(this.RADEG * Math.atan2(Math.cos(this.DEGRAD * ramc), - (Math.sin(this.DEGRAD * ramc) * Math.cos(this.DEGRAD * e) + Math.tan(this.DEGRAD * lat) * Math.sin(this.DEGRAD * e))) + 180);
            const mc = this.normalize(this.RADEG * Math.atan2(Math.tan(this.DEGRAD * ramc), Math.cos(this.DEGRAD * e)));
            
            houses[0] = ascendant;
            houses[3] = this.normalize(mc + 180);
            houses[6] = this.normalize(ascendant + 180);
            houses[9] = mc;

            const cuspCalc = (f) => {
                let K = Math.tan(this.DEGRAD * e) * Math.sin(this.DEGRAD * ramc + f);
                let XS = Math.atan(-Math.cos(this.DEGRAD * ramc + f) / (K * Math.cos(this.DEGRAD * lat) + Math.sin(this.DEGRAD * lat) * Math.sin(this.DEGRAD * e)));
                if (XS < 0) XS += Math.PI;
                if (Math.sin(this.DEGRAD * ramc + f) < 0) XS += Math.PI;
                return this.normalize(this.RADEG * Math.atan(Math.tan(XS) / Math.cos(this.DEGRAD * e)));
            };

            houses[1] = cuspCalc(120);
            houses[2] = cuspCalc(150);
            houses[4] = cuspCalc(210);
            houses[5] = cuspCalc(240);
            houses[7] = this.normalize(houses[1] + 180);
            houses[8] = this.normalize(houses[2] + 180);
            houses[10] = cuspCalc(30);
            houses[11] = cuspCalc(60);

            return houses;
        }

        getVertex(ramc, e, lat) {
            const primeVerticalLon = this.RADEG * Math.atan2(Math.cos(this.DEGRAD * ramc), - (Math.sin(this.DEGRAD * ramc) * Math.cos(this.DEGRAD * e) - Math.tan(this.DEGRAD * lat) * Math.sin(this.DEGRAD * e)));
            return this.normalize(primeVerticalLon + 180);
        }

        // --- REVISED: More accurate planetary models (simplified VSOP87) ---
        getSunLon(T) {
            const L = 280.46646 + 36000.76983 * T + 0.0003032 * T * T;
            const M = 357.52911 + 35999.05029 * T - 0.0001537 * T * T;
            const C = (1.914602 - 0.004817 * T - 0.000014 * T * T) * Math.sin(this.DEGRAD * M) +
                      (0.019993 - 0.000101 * T) * Math.sin(this.DEGRAD * 2 * M) +
                      0.000289 * Math.sin(this.DEGRAD * 3 * M);
            return L + C;
        }
        getMoonLon(T) {
            const L = 218.3164 + 481267.8813 * T; // Mean Longitude
            const D = 297.8502 + 445267.1115 * T; // Mean Elongation
            const M = 357.5291 + 35999.0503 * T;  // Sun's Mean Anomaly
            const M_ = 134.9634 + 477198.8676 * T; // Moon's Mean Anomaly
            const F = 93.2721 + 483202.0175 * T;   // Moon's Argument of Latitude
            const P1 = -1.274 * Math.sin(this.DEGRAD * (M_ - 2 * D));
            const P2 = +6.289 * Math.sin(this.DEGRAD * M_);
            const P3 = -0.658 * Math.sin(this.DEGRAD * 2 * D);
            // More terms needed for precision, but this is a good start
            return L + P1 + P2 + P3;
        }
        // Simplified models for other planets
        getMercuryLon(T) { return 252.2508 + 149472.6741 * T; }
        getVenusLon(T) { return 181.9798 + 58517.8159 * T; }
        getMarsLon(T) { return 355.4333 + 19140.2993 * T; }
        getJupiterLon(T) { return 34.3515 + 3034.9057 * T; }
        getSaturnLon(T) { return 50.0775 + 1222.1138 * T; }
        getUranusLon(T) { return 314.0550 + 428.4669 * T; }
        getNeptuneLon(T) { return 304.3487 + 218.4862 * T; }
        getPlutoLon(T) { return 238.9288 + 145.2078 * T; }
        getMeanNode(T) { return 125.0445 - 1934.1363 * T; }

        // --- Geocoding and other helpers (mostly unchanged) ---
        async geocodeLocation(location) {
            if (this.geocodeCache.has(location)) return this.geocodeCache.get(location);
            try {
                const results = await this.geocoder.geocode(location);
                if (!results || results.length === 0) return null;
                const result = { lat: results[0].latitude, lon: results[0].longitude, display_name: results[0].formattedAddress };
                this.geocodeCache.set(location, result);
                return result;
            } catch (error) { console.error(error); return null; }
        }
        async searchLocations(query) {
            if (!this.initialized || !query || query.length < 2) return [];
            try { return await this.geocoder.suggest(query, 5); } catch (error) { return []; }
        }
        getPlanetHouse(planetPosition, houses) {
            for (let house = 0; house < 12; house++) {
                const currentHouse = houses[house];
                const nextHouse = houses[(house + 1) % 12];
                if (currentHouse < nextHouse) {
                    if (planetPosition >= currentHouse && planetPosition < nextHouse) return house + 1;
                } else {
                    if (planetPosition >= currentHouse || planetPosition < nextHouse) return house + 1;
                }
            }
            return 1;
        }
        calculateNatalAspects(positions) {
            const planets = ['sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto', 'trueNode', 'chiron', 'ascendant', 'midHeaven'];
            const aspects = [];
            for (let i = 0; i < planets.length; i++) {
                for (let j = i + 1; j < planets.length; j++) {
                    const p1 = planets[i], p2 = planets[j];
                    if (positions[`${p1}Position`] === undefined || positions[`${p2}Position`] === undefined) continue;
                    const aspect = this.findAspect(positions[`${p1}Position`], positions[`${p2}Position`]);
                    if (aspect.name !== 'None') aspects.push({ planet1: p1, planet2: p2, ...aspect });
                }
            }
            return aspects;
        }
        findAspect(pos1, pos2) {
            const diff = Math.abs(pos1 - pos2);
            const angle = Math.min(diff, 360 - diff);
            const aspects = [
                { name: 'Conjunction', angle: 0, orb: 8, strength: 1.0 }, { name: 'Sextile', angle: 60, orb: 6, strength: 0.8 },
                { name: 'Square', angle: 90, orb: 8, strength: 0.6 }, { name: 'Trine', angle: 120, orb: 8, strength: 0.9 },
                { name: 'Opposition', angle: 180, orb: 8, strength: 0.7 }, { name: 'Semisextile', angle: 30, orb: 3, strength: 0.3 },
                { name: 'Quincunx', angle: 150, orb: 3, strength: 0.3 }, { name: 'Sesquiquadrate', angle: 135, orb: 3, strength: 0.4 }
            ];
            for (const aspect of aspects) {
                const aspectDiff = Math.abs(angle - aspect.angle);
                if (aspectDiff <= aspect.orb) {
                    const exactness = 1 - (aspectDiff / aspect.orb);
                    return { name: aspect.name, orb: aspectDiff.toFixed(2), strength: aspect.strength * exactness };
                }
            }
            return { name: 'None', orb: 0, strength: 0 };
        }
        async calculateCompatibility(user1, user2) {
            const venusMarsSynastry = (this.calculateAspectStrength(user1.venusPosition, user2.marsPosition) + this.calculateAspectStrength(user2.venusPosition, user1.marsPosition)) / 2;
            const fullChartSynastry = this.calculateFullChartSynastry(user1, user2);
            const synastryAspects = this.calculateSynastryAspects(user1, user2);
            const houseTranspositions = await this.calculateHouseTranspositions(user1, user2);
            const compatibilityScore = (venusMarsSynastry * 0.4) + (fullChartSynastry * 0.3) + (synastryAspects.score * 0.2) + (houseTranspositions.score * 0.1);
            return { compatibilityScore, venusMarsSynastry, fullChartSynastry, synastryAspects, houseTranspositions };
        }
        calculateAspectStrength(pos1, pos2) { return this.findAspect(pos1, pos2).strength; }
        calculateFullChartSynastry(user1, user2) {
            const planets = ['sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto', 'ascendant', 'midHeaven'];
            let totalAspects = 0, aspectCount = 0;
            for (const p1 of planets) {
                for (const p2 of planets) {
                    totalAspects += this.calculateAspectStrength(user1[`${p1}Position`], user2[`${p2}Position`]);
                    aspectCount++;
                }
            }
            return aspectCount > 0 ? totalAspects / aspectCount : 0;
        }
        calculateSynastryAspects(user1, user2) {
            const planets = ['sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn', 'ascendant', 'midHeaven'];
            const aspects = []; let totalScore = 0;
            planets.forEach(p1 => {
                planets.forEach(p2 => {
                    const aspect = this.findAspect(user1[`${p1}Position`], user2[`${p2}Position`]);
                    if (aspect.name !== 'None') {
                        aspects.push({ planet1: p1, planet2: p2, ...aspect });
                        totalScore += aspect.strength;
                    }
                });
            });
            return { aspects, score: aspects.length > 0 ? totalScore / aspects.length : 0 };
        }
        async calculateHouseTranspositions(user1, user2) {
            const transpositions = []; let harmoniousCount = 0;
            const planets = ['sun', 'moon', 'venus', 'mars', 'jupiter', 'saturn'];
            const coords = await this.geocodeLocation(user2.placeOfBirth);
            if (!coords) return { transpositions, score: 0 };
            const date = new Date(`${user2.dateOfBirth}T${user2.timeOfBirth}`);
            const jd_ut = this.getJulianDay(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours() + date.getUTCMinutes() / 60);
            const LST = this.getLST(jd_ut, coords.lon);
            const RAMC = LST * 15;
            const e = this.getMeanObliquity((this.getJulianDay(date.getFullYear(), 1, 1, 0) - 2451545.0) / 36525);
            const user2Houses = this.getPlacidusHouses(RAMC, e, coords.lat);
            planets.forEach(p => {
                const house = this.getPlanetHouse(user1[`${p}Position`], user2Houses);
                transpositions.push({ planet: p, house, owner: user1.username, inChart: user2.username });
                if ([1, 5, 7, 9, 11].includes(house)) harmoniousCount++;
            });
            return { transpositions, score: planets.length > 0 ? harmoniousCount / planets.length : 0 };
        }
        degreesToSign(degrees) {
            const normalizedDegrees = this.normalize(degrees);
            const signIndex = Math.floor(normalizedDegrees / 30);
            const degreesInSign = Math.floor(normalizedDegrees % 30);
            const minutes = Math.floor((normalizedDegrees * 60) % 60);
            return { sign: this.ZODIAC_SIGNS[signIndex], degreesInSign, minutes };
        }
        formatDetailedPlanetPosition(planetName, degrees, house) {
            const { sign, degreesInSign, minutes } = this.degreesToSign(degrees);
            return `${planetName}: ${degreesInSign}°${minutes.toString().padStart(2, '0')}' ${sign} in House ${house}`;
        }
        formatHouseCusp(houseNumber, degrees) {
            const { sign, degreesInSign, minutes } = this.degreesToSign(degrees);
            return `House ${houseNumber}: ${degreesInSign}°${minutes.toString().padStart(2, '0')}' ${sign}`;
        }
        generateNatalChartText(userData) {
            let text = `NATAL CHART for ${userData.username}\nBorn: ${userData.dateOfBirth} ${userData.timeOfBirth} in ${userData.placeOfBirth}\n\nPLANETS:\n`;
            const planets = ['sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto', 'trueNode', 'chiron', 'fortuna', 'vertex', 'ascendant', 'midHeaven'];
            planets.forEach(p => {
                const pos = userData[`${p}Position`];
                const house = userData[`${p}PositionHouse`];
                if (pos !== undefined && house !== undefined) {
                    text += this.formatDetailedPlanetPosition(p.charAt(0).toUpperCase() + p.slice(1), pos, house) + '\n';
                }
            });
            text += '\nASPECTS:\n';
            if (userData.natalAspects) {
                userData.natalAspects.forEach(a => { text += `${a.planet1} ${a.name} ${a.planet2} (orb: ${a.orb}°)\n`; });
            }
            return text;
        }
        generateSynastryText(user1, user2, synastryData) {
            let text = `SYNASTRY: ${user1.username} & ${user2.username}\n\n`;
            text += `Overall Score: ${(synastryData.compatibilityScore * 100).toFixed(1)}%\n`;
            text += `Venus-Mars: ${(synastryData.venusMarsSynastry * 100).toFixed(1)}%\n\nASPECTS:\n`;
            synastryData.synastryAspects.aspects.forEach(a => { text += `${user1.username}'s ${a.planet1} ${a.name} ${user2.username}'s ${a.planet2} (orb: ${a.orb}°)\n`; });
            return text;
        }
    }

    // --- network.js ---
    class NetworkEngine {
        constructor() {
            this.connections = new Map();
            this.myPeerId = this.generatePeerId();
            this.startSignalingListener();
        }
        generatePeerId() { return 'peer_' + Math.random().toString(36).substring(2, 11); }
        startSignalingListener() { setInterval(() => this.checkSignalingMessages(), 1000); }
        checkSignalingMessages() {
            try {
                const signals = JSON.parse(localStorage.getItem('p2p_signals') || '[]');
                const unprocessed = [];
                signals.forEach(signal => {
                    if (signal.to === this.myPeerId) {
                        this.handleSignalingMessage(signal);
                    } else {
                        unprocessed.push(signal);
                    }
                });
                localStorage.setItem('p2p_signals', JSON.stringify(unprocessed));
            } catch (e) { localStorage.removeItem('p2p_signals'); }
        }
        handleSignalingMessage(signal) {
            if (signal.type === 'chat-message') {
                const { message, from, timestamp } = signal.data;
                const history = app.chatHistory.get(from) || [];
                history.push({ from, message, timestamp: new Date(timestamp), type: 'received' });
                app.chatHistory.set(from, history);
                if (app.currentChatUser && app.currentChatUser.id === from) {
                    updateChatDisplay();
                } else {
                    const fromUser = app.matches.find(m => m.id === from);
                    if (fromUser) {
                        app.addNotification({ type: 'new_message', from: fromUser, message: 'sent you a message', timestamp: new Date() });
                    }
                }
            }
        }
        sendSignalingMessage(to, type, data) {
            try {
                const signals = JSON.parse(localStorage.getItem('p2p_signals') || '[]');
                signals.push({ from: this.myPeerId, to, type, data, timestamp: Date.now() });
                localStorage.setItem('p2p_signals', JSON.stringify(signals));
            } catch (e) { localStorage.setItem('p2p_signals', '[]'); }
        }
        connectToPeer(peerId) { /* Simulated connection */ }
        sendMessage(peerId, message) {
            this.sendSignalingMessage(peerId, 'chat-message', { message, from: this.myPeerId, timestamp: new Date().toISOString() });
            const history = app.chatHistory.get(peerId) || [];
            history.push({ from: this.myPeerId, message, timestamp: new Date(), type: 'sent' });
            app.chatHistory.set(peerId, history);
            updateChatDisplay();
        }
        announcePresence(userData) {
            try {
                const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]').filter(a => a.peerId !== this.myPeerId);
                announcements.push({ peerId: this.myPeerId, userData, timestamp: Date.now(), ipAddress: app.getUserIP() });
                const recent = announcements.filter(a => Date.now() - a.timestamp < 300000);
                localStorage.setItem('p2p_announcements', JSON.stringify(recent));
            } catch (e) { localStorage.setItem('p2p_announcements', '[]'); }
        }
        discoverPeers() {
            try {
                const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                return announcements
                    .filter(a => a.peerId !== this.myPeerId && !app.mutedIPs.has(a.ipAddress))
                    .filter(a => Date.now() - a.timestamp < 300000)
                    .map(a => ({ ...a.userData, id: a.peerId, peerId: a.peerId, ipAddress: a.ipAddress }));
            } catch (e) { return []; }
        }
    }

    // --- ui.js ---
    function showScreen(screenName) {
        ['welcomeScreen', 'matchesScreen'].forEach(screen => {
            document.getElementById(screen).classList.toggle('hidden', screen !== screenName);
        });
    }
    
    function showToast(message) {
        const toast = document.getElementById('toastNotification');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 3000);
    }

    async function connect() {
        const username = document.getElementById('username').value.trim();
        const dateOfBirth = document.getElementById('dateOfBirth').value;
        const timeOfBirth = document.getElementById('timeOfBirth').value;
        const placeOfBirth = document.getElementById('placeOfBirth').value.trim();
        if (!username || !dateOfBirth || !timeOfBirth || !placeOfBirth) {
            showToast("Please fill in all fields.");
            return;
        }
        document.getElementById('connectBtn').disabled = true;
        document.getElementById('connectBtn').textContent = 'Calculating Chart...';

        const natalPositions = await astrology.calculateNatalChart(dateOfBirth, timeOfBirth, placeOfBirth);
        if (!natalPositions) {
            showToast("Could not geocode location. Please try a different name.");
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('connectBtn').textContent = 'Connect to Searchster Network';
            return;
        }
        
        app.currentUser = {
            id: network.myPeerId,
            username,
            ipAddress: app.getUserIP(),
            displayName: `${username}@${app.getUserIP()}`,
            dateOfBirth, timeOfBirth, placeOfBirth,
            timeCertain: document.getElementById('timeCertain').checked,
            gender: document.querySelector('input[name="gender"]:checked').value,
            lookingForMen: document.getElementById('lookingForMen').checked,
            lookingForWomen: document.getElementById('lookingForWomen').checked,
            ...natalPositions,
            bio: 'A cosmic traveler seeking connection.',
            profileImage: `https://placehold.co/80x80/8b5cf6/ffffff?text=${username.charAt(0).toUpperCase()}`,
            age: calculateAge(dateOfBirth)
        };
        
        network.announcePresence(app.currentUser);
        showScreen('matchesScreen');
        document.querySelector('.profile-btn').classList.add('visible');
        findMatches();
    }

    function calculateAge(dateOfBirth) {
        const ageDifMs = Date.now() - new Date(dateOfBirth).getTime();
        const ageDate = new Date(ageDifMs);
        return Math.abs(ageDate.getUTCFullYear() - 1970);
    }

    async function findMatches() {
        const minAge = parseInt(document.getElementById('minAge').value);
        const maxAge = parseInt(document.getElementById('maxAge').value);
        const peers = network.discoverPeers();
        
        const filtered = peers.filter(user => {
            if (!user.dateOfBirth) return false;
            const userAge = calculateAge(user.dateOfBirth);
            user.age = userAge;
            const ageMatch = userAge >= minAge && userAge <= maxAge;
            const userWantsMe = (app.currentUser.gender === 'man' && user.lookingForMen) || (app.currentUser.gender === 'woman' && user.lookingForWomen);
            const iWantUser = (user.gender === 'man' && app.currentUser.lookingForMen) || (user.gender === 'woman' && app.currentUser.lookingForWomen);
            return ageMatch && userWantsMe && iWantUser;
        });

        const matches = await Promise.all(filtered.map(async user => {
            const compatibility = await astrology.calculateCompatibility(app.currentUser, user);
            return { ...user, ...compatibility };
        }));
        
        matches.sort((a, b) => b.compatibilityScore - a.compatibilityScore);
        app.matches = matches;
        displayMatches(matches);
    }

    function displayMatches(matches) {
        const matchesList = document.getElementById('matchesList');
        if (matches.length === 0) {
            matchesList.innerHTML = `<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No compatible users found on the network. Try again later.</div>`;
            return;
        }
        matchesList.innerHTML = matches.map(createMatchCard).join('');
    }

    function createMatchCard(match) {
        const verifiedBadge = match.timeCertain ? '<span class="badge badge-golden">✓ Verified</span>' : '';
        const genderBadge = match.gender === 'man' ? '<span class="badge badge-male">♂</span>' : '<span class="badge badge-female">♀</span>';
        
        return `
            <div class="match-card" onclick="openChat('${match.id}')">
                <div class="match-header">
                    <div class="match-username">${genderBadge} ${verifiedBadge} <span>${match.displayName}</span></div>
                    <div class="compatibility-score">${(match.compatibilityScore * 100).toFixed(1)}%</div>
                </div>
                <div class="match-details">
                    <div class="detail-item"><div class="detail-label">Age</div><div class="detail-value">${match.age}</div></div>
                    <div class="detail-item"><div class="detail-label">Venus-Mars</div><div class="detail-value">${(match.venusMarsSynastry * 100).toFixed(1)}%</div></div>
                    <div class="detail-item"><div class="detail-label">Full Chart</div><div class="detail-value">${(match.fullChartSynastry * 100).toFixed(1)}%</div></div>
                    <div class="detail-item"><div class="detail-label">Location</div><div class="detail-value">${match.placeOfBirth.split(',')[0]}</div></div>
                </div>
            </div>`;
    }

    function openChat(userId) {
        const user = app.matches.find(m => m.id === userId);
        if (!user) return;
        app.currentChatUser = user;
        network.connectToPeer(userId);
        document.getElementById('chatUsername').textContent = user.displayName;
        updateChatDisplay();
        document.getElementById('chatPanel').classList.add('open');
    }

    function closeChat() {
        document.getElementById('chatPanel').classList.remove('open');
        app.currentChatUser = null;
    }

    function sendMessage() {
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        if (message && app.currentChatUser) {
            network.sendMessage(app.currentChatUser.id, message);
            input.value = '';
        }
    }

    function handleChatKeyPress(event) { if (event.key === 'Enter') { event.preventDefault(); sendMessage(); } }

    function updateChatDisplay() {
        if (!app.currentChatUser) return;
        const messagesContainer = document.getElementById('chatMessages');
        const messages = app.chatHistory.get(app.currentChatUser.id) || [];
        messagesContainer.innerHTML = messages.map(msg => {
            const isOwn = msg.from === app.currentUser.id;
            const className = isOwn ? 'message own' : 'message other';
            const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<div class="${className}"><div>${msg.message}</div><div style="font-size: 0.8em; opacity: 0.7; margin-top: 0.5rem;">${time}</div></div>`;
        }).join('');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function saveChat() {
        if (!app.currentChatUser) return;
        const messages = app.chatHistory.get(app.currentChatUser.id) || [];
        const chatText = messages.map(msg => `[${new Date(msg.timestamp).toLocaleString()}] ${msg.from === app.currentUser.id ? app.currentUser.username : app.currentChatUser.username}: ${msg.message}`).join('\n');
        const blob = new Blob([chatText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chat_${app.currentChatUser.username}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }

    async function openProfile() { await showProfile(app.currentUser, true); }
    async function viewChatUserProfile() {
        const compatibility = await astrology.calculateCompatibility(app.currentUser, app.currentChatUser);
        await showProfile(app.currentChatUser, false, compatibility);
    }

    async function showProfile(user, isOwnProfile, synastryData = null) {
        const content = document.getElementById('profileContent');
        const verifiedBadge = user.timeCertain ? '<span class="badge badge-golden">✓ Verified</span>' : '';
        const genderBadge = user.gender === 'man' ? '<span class="badge badge-male">♂</span>' : '<span class="badge badge-female">♀</span>';
        
        let html = `
            <div class="profile-header">
                <div class="profile-avatar"><img src="${user.profileImage}" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;"></div>
                <div>
                    <h2>${genderBadge} ${verifiedBadge} ${user.displayName}</h2>
                    <p style="color: var(--text-muted);">Born: ${user.dateOfBirth} at ${user.timeOfBirth}</p>
                    <p style="color: var(--text-muted);">Location: ${user.placeOfBirth}</p>
                </div>
            </div>
            <div style="margin-bottom: 2rem;">
                <h3 style="color: var(--cosmic-purple); margin-bottom: 1rem;">Bio</h3>
                <div style="background: rgba(51, 65, 85, 0.5); border-radius: 0.5rem; padding: 1rem; min-height: 60px;">${user.bio || ''}</div>
            </div>
            <div style="margin-bottom: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="color: var(--cosmic-purple);">Natal Chart</h3>
                    <button class="copy-btn" onclick="copyNatalData('${user.id}')">Copy Data</button>
                </div>
                <div class="natal-data" style="font-family: monospace; font-size: 0.9rem; line-height: 1.6;">${await generateNatalDataHTML(user)}</div>
            </div>
        `;
        
        if (synastryData) {
            html += `
                <div>
                    <h3 style="color: var(--cosmic-purple); margin-bottom: 1rem;">Synastry Analysis</h3>
                    <div class="natal-data">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                            <div><div style="font-size: 1.2rem; font-weight: bold; color: var(--cosmic-purple);">${(synastryData.compatibilityScore * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: var(--text-muted);">Overall</div></div>
                            <div><div style="font-size: 1.2rem; font-weight: bold; color: var(--cosmic-pink);">${(synastryData.venusMarsSynastry * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: var(--text-muted);">Venus-Mars</div></div>
                            <div><div style="font-size: 1.2rem; font-weight: bold; color: var(--text-white);">${(synastryData.fullChartSynastry * 100).toFixed(1)}%</div><div style="font-size: 0.8rem; color: var(--text-muted);">Full Chart</div></div>
                        </div>
                    </div>
                </div>`;
        }
        
        content.innerHTML = html;
        document.getElementById('profileModal').classList.remove('hidden');
    }

    async function generateNatalDataHTML(user) {
        if (!user.houses) {
            Object.assign(user, await astrology.calculateNatalChart(user.dateOfBirth, user.timeOfBirth, user.placeOfBirth));
        }
        const planets = ['sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto', 'ascendant', 'midHeaven'];
        let html = planets.map(p => `<div>${astrology.formatDetailedPlanetPosition(p.charAt(0).toUpperCase() + p.slice(1), user[`${p}Position`], user[`${p}PositionHouse`])}</div>`).join('');
        html += '<hr style="margin: 1rem 0; border-color: var(--cosmic-purple);">';
        for (let i = 1; i <= 12; i++) {
            html += `<div>${astrology.formatHouseCusp(i, user.houses[i - 1])}</div>`;
        }
        return html;
    }

    function closeProfile() { document.getElementById('profileModal').classList.add('hidden'); }

    function copyNatalData(userId) {
        const user = (app.currentUser && app.currentUser.id === userId) ? app.currentUser : app.matches.find(m => m.id === userId);
        if (user) {
            const natalText = astrology.generateNatalChartText(user);
            navigator.clipboard.writeText(natalText).then(() => showToast('Natal data copied!'));
        }
    }

    function toggleNotifications() {
        const modal = document.getElementById('notificationModal');
        if (!modal.classList.contains('hidden')) {
            closeNotifications();
            return;
        }
        const list = document.getElementById('notificationsList');
        app.notifications.forEach(n => n.read = true);
        app.updateNotificationBell();
        list.innerHTML = app.notifications.length > 0 ? app.notifications.map(createNotificationHTML).join('') : '<p>No new notifications.</p>';
        modal.classList.remove('hidden');
    }

    function createNotificationHTML(n) {
        return `<div style="border-bottom: 1px solid var(--dark-blue-700); padding: 1rem 0;">
            <strong>${n.from.username}</strong> ${n.message} <span style="font-size: 0.8rem; color: var(--text-muted); float: right;">${n.timestamp.toLocaleTimeString()}</span>
        </div>`;
    }

    function closeNotifications() { document.getElementById('notificationModal').classList.add('hidden'); }

    function initializeLocationAutocomplete() {
        bindAutocomplete(document.getElementById('placeOfBirth'), document.getElementById('locationSuggestions'));
        bindAutocomplete(document.getElementById('settingsPlaceOfBirth'), document.getElementById('settingsLocationSuggestions'));
    }

    function bindAutocomplete(input, box) {
        let timer;
        input.addEventListener('input', e => {
            clearTimeout(timer);
            const q = e.target.value.trim();
            if (q.length < 2) { box.classList.add('hidden'); return; }
            timer = setTimeout(async () => {
                try {
                    const suggestions = await astrology.searchLocations(q);
                    showLocationSuggestions(suggestions, box, input);
                } catch (error) { box.classList.add('hidden'); }
            }, 300);
        });
        document.addEventListener('click', (e) => {
             if (!input.contains(e.target) && !box.contains(e.target)) {
                box.classList.add('hidden');
            }
        });
    }

    function showLocationSuggestions(suggestions, suggestionsDiv, inputElement) {
        if (!suggestions || suggestions.length === 0) {
            suggestionsDiv.classList.add('hidden'); return;
        }
        suggestionsDiv.innerHTML = suggestions.map(s => `<div class="location-suggestion">${s.display_name}</div>`).join('');
        suggestionsDiv.querySelectorAll('.location-suggestion').forEach(item => {
            item.addEventListener('click', () => {
                inputElement.value = item.textContent;
                suggestionsDiv.classList.add('hidden');
            });
        });
        suggestionsDiv.classList.remove('hidden');
    }

    function openSettings() {
        const u = app.currentUser;
        document.getElementById('settingsUsername').value = u.username;
        document.getElementById('settingsDateOfBirth').value = u.dateOfBirth;
        document.getElementById('settingsTimeOfBirth').value = u.timeOfBirth;
        document.getElementById('settingsPlaceOfBirth').value = u.placeOfBirth;
        document.getElementById('settingsGender').value = u.gender;
        document.getElementById('settingsTimeCertain').checked = u.timeCertain;
        document.getElementById('settingsLookingForMen').checked = u.lookingForMen;
        document.getElementById('settingsLookingForWomen').checked = u.lookingForWomen;
        document.getElementById('settingsBio').value = u.bio;
        document.getElementById('settingsModal').classList.remove('hidden');
    }

    function closeSettings() { document.getElementById('settingsModal').classList.add('hidden'); }

    async function saveSettings() {
        const u = app.currentUser;
        const birthInfoChanged = (
            u.dateOfBirth !== document.getElementById('settingsDateOfBirth').value ||
            u.timeOfBirth !== document.getElementById('settingsTimeOfBirth').value ||
            u.placeOfBirth !== document.getElementById('settingsPlaceOfBirth').value
        );

        u.username = document.getElementById('settingsUsername').value;
        u.dateOfBirth = document.getElementById('settingsDateOfBirth').value;
        u.timeOfBirth = document.getElementById('settingsTimeOfBirth').value;
        u.placeOfBirth = document.getElementById('settingsPlaceOfBirth').value;
        u.gender = document.getElementById('settingsGender').value;
        u.timeCertain = document.getElementById('settingsTimeCertain').checked;
        u.lookingForMen = document.getElementById('settingsLookingForMen').checked;
        u.lookingForWomen = document.getElementById('settingsLookingForWomen').checked;
        u.bio = document.getElementById('settingsBio').value.substring(0, 500);
        u.displayName = `${u.username}@${u.ipAddress}`;
        
        if (birthInfoChanged) {
            const natalChart = await astrology.calculateNatalChart(u.dateOfBirth, u.timeOfBirth, u.placeOfBirth);
            Object.assign(u, natalChart);
        }
        
        network.announcePresence(u);
        closeSettings();
        findMatches();
        showToast("Settings saved!");
    }

    // --- APP INITIALIZATION ---
    let app, astrology, network;
    document.addEventListener('DOMContentLoaded', function() {
        app = new SearchsterApp();
        astrology = new AstrologyEngine();
        network = new NetworkEngine();
        
        astrology.initialize();
        app.initializeDOMFeatures();
        initializeLocationAutocomplete();
        
        console.log('Searchster initialized successfully');
    });
    </script>
</body>
</html>
